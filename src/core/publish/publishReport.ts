import type { PublishError, PublishResult, PublishTarget } from "../../types/publish.js";
import { buildIssueLabels } from "./labels.js";
import { buildPublishReport, extractPotentialIssues, type PotentialIssue } from "./reportBuilder.js";
import { createIssue } from "../../providers/githubPublish.js";
import { isAuthenticated } from "../../providers/github.js";
import type { Category, Priority } from "../../types/schema.js";

export interface PublishRequest {
  target?: PublishTarget;
  repo: {
    owner: string;
    name: string;
    fullName: string;
    url: string;
  };
  analysisContent: string;
  token?: string;
  categories?: Category[];
}

function inferPriority(text: string): Priority {
  const lower = text.toLowerCase();
  if (lower.includes("p0") || lower.includes("critical")) return "P0";
  if (lower.includes("p1") || lower.includes("high priority")) return "P1";
  if (lower.includes("p2") || lower.includes("suggestion")) return "P2";
  return "P2";
}

function inferCategory(text: string): Category {
  const lower = text.toLowerCase();
  if (/(readme|docs|documentation|onboarding)/.test(lower)) return "docs";
  if (/(ci\/cd|cicd|workflow|github actions|pipeline)/.test(lower)) return "ci";
  if (/(test|testing|coverage|vitest|unit test|integration test)/.test(lower)) return "tests";
  if (/(security|vulnerab|token|secret|prompt injection)/.test(lower)) return "security";
  if (/(license|governance|code of conduct|security policy|dependabot|renovate|nvmrc)/.test(lower)) {
    return "governance";
  }
  return "dx";
}

function buildIssueBody(issue: PotentialIssue): string {
  const lines: string[] = [];
  lines.push(`## Summary`);
  lines.push(issue.summary || issue.title);
  lines.push("");

  lines.push("## Evidence");
  if (issue.evidence) {
    lines.push(issue.evidence);
  } else if (issue.details) {
    lines.push(issue.details);
  } else {
    lines.push("See analysis report for full context.");
  }
  lines.push("");

  lines.push("## Impact");
  lines.push(issue.impact || "See analysis report for impact details.");
  lines.push("");

  lines.push("## Recommended Fix");
  lines.push(issue.fix || "See analysis report for recommended fix.");
  lines.push("");

  lines.push("---");
  lines.push("_Generated by Repo Doctor._");
  return lines.join("\n");
}

function mapPublishError(error: unknown): { type: PublishError["type"]; message: string } {
  const message = error instanceof Error ? error.message : "Unknown publish error";
  const status = (error as { status?: number }).status;

  if (status === 401) return { type: "permission", message };
  if (status === 403) {
    if (message.toLowerCase().includes("rate limit")) {
      return { type: "rate_limited", message };
    }
    return { type: "permission", message };
  }
  if (status === 404) return { type: "not_found", message };

  return { type: "unknown", message };
}

export async function publishReport(request: PublishRequest): Promise<PublishResult | null> {
  const { target, repo, analysisContent, token, categories = [] } = request;
  const inferredCategories = categories.length > 0 ? categories : extractCategories(analysisContent);

  if (!target) return null;

  if (!isAuthenticated(token)) {
    return {
      ok: false,
      target,
      error: {
        type: "missing_token",
        message: "Missing GitHub token for publishing.",
      },
    };
  }

  try {
    const labels = buildIssueLabels(inferredCategories);
    const title = `Repo Doctor Report: ${repo.fullName}`;

    const potentialIssues = extractPotentialIssues(analysisContent);
    if (potentialIssues.length > 0) {
      const targetUrls: string[] = [];

      for (const issue of potentialIssues) {
        const combinedText = [issue.title, issue.summary, issue.impact, issue.fix, issue.details]
          .filter(Boolean)
          .join("\n");
        const category = inferCategory(combinedText);
        const priority = inferPriority(combinedText);

        const issueLabels = buildIssueLabels([category]);
        issueLabels.push(priority);

        const issueTitle = `[Repo Doctor] ${category}: ${issue.title}`;
        const issueBody = buildIssueBody(issue);
        const issueUrl = await createIssue({
          owner: repo.owner,
          repo: repo.name,
          title: issueTitle,
          body: issueBody,
          labels: issueLabels,
          token,
        });
        targetUrls.push(issueUrl);
      }

      return { ok: true, target, targetUrls };
    }

    const { markdown } = buildPublishReport({
      content: analysisContent,
      repoFullName: repo.fullName,
    });

    const targetUrl = await createIssue({
      owner: repo.owner,
      repo: repo.name,
      title,
      body: markdown,
      labels,
      token,
    });

    return { ok: true, target, targetUrl };
  } catch (error) {
    return {
      ok: false,
      target,
      error: mapPublishError(error),
    };
  }
}

function extractCategories(content: string): Category[] {
  const patterns: Array<{ category: Category; regex: RegExp }> = [
    { category: "docs", regex: /Docs\s*&\s*Onboarding|\bdocs\b/i },
    { category: "dx", regex: /Developer\s*Experience|\bdx\b/i },
    { category: "ci", regex: /CI\/CD|\bci\b/i },
    { category: "tests", regex: /Quality\s*&\s*Tests|\btests\b/i },
    { category: "governance", regex: /Governance/gi },
    { category: "security", regex: /Security/gi },
  ];

  const detected = new Set<Category>();
  for (const pattern of patterns) {
    if (pattern.regex.test(content)) detected.add(pattern.category);
  }
  return Array.from(detected);
}
